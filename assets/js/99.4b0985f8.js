(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{415:function(v,_,e){"use strict";e.r(_);var o=e(7),t=Object(o.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("参考文章："),_("a",{attrs:{href:"https://www.myfreax.com/gitignore-ignoring-files-in-git/",target:"_blank",rel:"noopener noreferrer"}},[v._v("如何使用.gitignore 忽略 Git 中的文件和目录"),_("OutboundLink")],1)]),v._v(" "),_("h2",{attrs:{id:"gitignore-模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#gitignore-模式"}},[v._v("#")]),v._v(" .gitignore 模式")]),v._v(" "),_("p",[v._v(".gitignore 文件是纯文本文件，其中每行包含一个模式，用于忽略文件或目录。.gitignore 使用 globbing pattern 模式来匹配带通配符的文件名。如果文件或目录包含在通配符，则可以使用单个反斜杠（\\）来转义字")]),v._v(" "),_("h2",{attrs:{id:"注释"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#注释"}},[v._v("#")]),v._v(" 注释")]),v._v(" "),_("p",[v._v("以"),_("code",[v._v("#")]),v._v("开头的行是注释，将被忽略")]),v._v(" "),_("h2",{attrs:{id:"斜杠符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#斜杠符"}},[v._v("#")]),v._v(" 斜杠符")]),v._v(" "),_("p",[v._v("斜杠符号（/）是目录的分隔符。\n"),_("u",[v._v("斜杠开头")]),v._v("模式相对于"),_("code",[v._v(".gitignore")]),v._v(" 所在的目录。如果模式以斜杠开头，则仅从仓库的根目录中开始匹配文件和目录。如果模式不是以斜杠开头，则它将匹配任何目录或子目录中的文件和目录。")]),v._v(" "),_("p",[v._v("如果模式以"),_("u",[v._v("斜杠结尾")]),v._v("，则仅匹配目录。当目录被忽略时，其所有文件和子目录也将被忽略。")]),v._v(" "),_("h2",{attrs:{id:"文件名"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#文件名"}},[v._v("#")]),v._v(" 文件名")]),v._v(" "),_("p",[v._v("最直接的模式是没有任何特殊字符的文件名。例如/access.log 仅匹配 access.log。而 access.log 将会匹配当前目录与子目录 access.log，logs/access.log ，var/logs/access.log。当以/斜杠符号结束时则匹配目录。例如 build/匹配 build 目录。")]),v._v(" "),_("h2",{attrs:{id:"通配符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#通配符"}},[v._v("#")]),v._v(" 通配符")]),v._v(" "),_("p",[_("code",[v._v("*")]),v._v("星号符号匹配零个或多个字符。例如"),_("code",[v._v("*.log")]),v._v("模式将匹配"),_("code",[v._v("error.log")]),v._v("，"),_("code",[v._v("logs/debug.log")]),v._v("，"),_("code",[v._v("build/logs/error.log")]),v._v("等所有目录下以"),_("code",[v._v(".log")]),v._v("作为扩展名的文件。")]),v._v(" "),_("p",[_("code",[v._v("**")]),v._v("两个相邻的星号符号匹配任何文件或零个或多个目录。\n当后跟斜杠"),_("code",[v._v("（/）")]),v._v("时，它仅与目录匹配。例如:\n"),_("code",[v._v("logs/**")]),v._v("将会匹配"),_("code",[v._v("logs")]),v._v("目录中所有文件与目录;\n"),_("code",[v._v("**/build")]),v._v("将匹配所有目录中出现以"),_("code",[v._v("build")]),v._v("命名目录与文件"),_("code",[v._v("var/build")]),v._v("，"),_("code",[v._v("pub/build")]),v._v("。")]),v._v(" "),_("p",[v._v("模式"),_("code",[v._v("foo/**/bar")]),v._v("将匹配"),_("code",[v._v("​foo/bar")]),v._v("，"),_("code",[v._v("foo/a/bar")]),v._v("，"),_("code",[v._v("foo/a/b/c/bar")]),v._v("。")]),v._v(" "),_("p",[_("code",[v._v("?")]),v._v("问号匹配单个任意字符。例如模式"),_("code",[v._v("access?.log")]),v._v("将会匹配"),_("code",[v._v("access0.log")]),v._v("，"),_("code",[v._v("access1.log")]),v._v("，"),_("code",[v._v("accessA.log")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"方括号"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方括号"}},[v._v("#")]),v._v(" 方括号")]),v._v(" "),_("p",[_("code",[v._v("[...]")]),v._v("方括号匹配方括号中包含的字符。当两个字符之间用连字符"),_("code",[v._v("-")]),v._v("隔开时，表示一个字符范围。该范围包括这两个字符之间的所有字符。范围可以是字母或数字。如果"),_("code",[v._v("[")]),v._v("之后的第一个字符是感叹号"),_("code",[v._v("（!）")]),v._v("，则该模式匹配除指定集合中的字符以外的任何字符。")]),v._v(" "),_("p",[v._v("例如模式"),_("code",[v._v("*.[oa]")]),v._v("将匹配文件"),_("code",[v._v("file.o")]),v._v("，"),_("code",[v._v("file.a")]),v._v("。模式"),_("code",[v._v("*.[!oa]")]),v._v("将匹配"),_("code",[v._v("file.s")]),v._v("，"),_("code",[v._v("file.1")]),v._v("但不匹配"),_("code",[v._v("file.0")]),v._v("与"),_("code",[v._v("file.a")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"反模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#反模式"}},[v._v("#")]),v._v(" 反模式")]),v._v(" "),_("p",[v._v("以感叹号"),_("code",[v._v("（!）")]),v._v("开头的模式将否定先前模式。此规则的例外是，如果排除了其父目录，则重新包含文件。例如模式 "),_("code",[v._v("*.log")]),v._v("与"),_("code",[v._v("!error.log")]),v._v("这将会匹配所有以"),_("code",[v._v(".log")]),v._v("作为扩展名文件，但不匹配"),_("code",[v._v("error.log")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"本地-gitignore"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#本地-gitignore"}},[v._v("#")]),v._v(" 本地.gitignore")]),v._v(" "),_("p",[v._v("本地"),_("code",[v._v(".gitignore")]),v._v("文件通常放置在仓库库的根目录中。但是，您可以在仓库的不同子目录中创建多个"),_("code",[v._v(".gitignore")]),v._v("文件。 "),_("code",[v._v(".gitignore")]),v._v("文件中的模式相对于文件所在目录匹配。")]),v._v(" "),_("p",[v._v("在子目录中的文件中定义的模式优先于高于根目录中的模式。本地"),_("code",[v._v(".gitignore")]),v._v("文件与其他开发人员共享，并且应包含对存储库的所有其他用户有用的模式。")]),v._v(" "),_("h2",{attrs:{id:"个人忽略规则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#个人忽略规则"}},[v._v("#")]),v._v(" 个人忽略规则")]),v._v(" "),_("p",[v._v("应在"),_("code",[v._v(".git/info/exclude")]),v._v("文件中配置特定于本地仓库且不应分发到其他仓库的模式。例如，您可以使用此文件忽略个人项目工具中生成的文件。")]),v._v(" "),_("h2",{attrs:{id:"全局-gitignore"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#全局-gitignore"}},[v._v("#")]),v._v(" 全局.gitignore")]),v._v(" "),_("p",[v._v("Git 还允许您创建全局"),_("code",[v._v(".gitignore")]),v._v("文件，您可以为本地系统上的每个 Git 仓库定义忽略规则。该文件可以命名为任意名称，并存储在任何位置。保存此文件的最常见位置是主目录。您必须手动创建文件并配置 Git 使用它。")])])}),[],!1,null,null,null);_.default=t.exports}}]);