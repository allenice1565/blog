(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{345:function(t,e,a){"use strict";a.r(e);var c=a(7),s=Object(c.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[e("code",[t._v("useEffect")]),t._v("可以在函数组件中执行副作用操作，通过这个 hook，可以告诉 React 组件需要在渲染后执行某些操作，React 会在执行完 DOM 更新后调用传递给 useEffect 的回调函数")]),t._v(" "),e("p",[t._v("将 useEffect 放在组件内部让我们可以在 effect 中直接访问 count state 变量（或其他 props）。我们不需要特殊的 API 来读取它 —— 它已经保存在函数作用域中。Hook 使用了 JavaScript 的闭包机制，而不用在 JavaScript 已经提供了解决方案的情况下，还引入特定的 React API。")]),t._v(" "),e("p",[t._v("在 vue2 中，功能相似于 watch（immediate: true），在 vue3 中，相似于 watchEffect。")]),t._v(" "),e("blockquote",[e("p",[t._v("纯函数（pure function）指的是函数内部操作的数据不会操作函数外部的变量，除了 return 之外，不会改变函数外部的变量。\n副作用指的是在函数执行期间，操作了外部变量。")])]),t._v(" "),e("h3",{attrs:{id:"usecallback"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#usecallback"}},[t._v("#")]),t._v(" useCallback")]),t._v(" "),e("p",[t._v("每次重新渲染的时候，可以将方法的实现留存下来，不用再重新创建了，单例模式")])])}),[],!1,null,null,null);e.default=s.exports}}]);